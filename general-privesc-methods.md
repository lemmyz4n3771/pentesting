## General Privilege Escalation Methods

There are a finite number of high-level ways to privesc after gaining the foothold: 

**Abuse privileges**: There is something that a particular user can do which leads to greater compromise. Here, you're looking for users. You may have to find ways to pivot from user to user until you get root, but still it's all about targeting users to gain different levels of privileges. Pivoting here will require some form of authentication (user creds, certificate, Kerberos ticket) or inheriting a process initiated by that user (via phishing, cronjob, or some automatic scripting).

**Abuse misconfigurations**: There is read/write/execute access to something that can be leveraged. Here, you're looking for a file or directory or currently running service. Enumeration here can be automated, but will require you understand the significance of the findings to privesc manually.

**Abuse a vulnerability in the system itself**: Here you're looking for a kernel exploit. This, too can be automated, since it just involves checking different versions of the system. Assuming no patches or hotfixes, implementing the exploit can also be largely automatic and provide a quick win, even from a low-privileged user or service account.

**Abuse currently running services, automated scripts,  and cronjobs**: Here, you're looking for processes that run periodically, including those that can be turned off and turned on again. On Linux machines, you can easily find these with ![pspy](https://github.com/DominicBreuker/pspy). On Windows, this can similarly be done with ![procmon](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon) (Process Monitor) from the Sysinternals suite, although I haven't found this to be as easy as with pspy. So, to do this in Windows, you'll have to familiarize yourself with ways of querying running services through Powershell that are unavailable in Linux.

**Abuse insecure binaries**: Here, you're looking for applications that are intended to be accessed, but they are written in such a way that a user can gain additional functionality beyond its original intented design. When you find such vulnerable applications, you're then looking for places where you have control over the input, which becomes your point of entry for an attack, like buffer overflow. To do this, you need some access to the executable or its source code to the look at to how it is made.

**Abuse dependencies**: Here, you've found a service or binary that you want to exploit, but something perhaps prevents you from exploiting it directly via user input. Instead, you're now looking for things that are needed by the binary to function such that, when it runs it will execute the thing you've hijacked. To do this, you'll also need some idea of the source code, either through a disassembler, hex viewer, or some other reverse engineering tool, or checking out the ascii strings in the binary to see what is called. This is easier to do with ELF files than Windows binaries, especially when attacking using Kali. A Windows binary usually involves analyzing it in a Windows VM with tools like ![DNSpy](https://github.com/dnSpy/dnSpy).

Although few in number, each method here encompasses a lot of variation, but this is the general outline of each.

The final thing to realize is that these attack paths, although defined in theory, overlap in practice. In picking one path, you may find out later that it doesn't work. However, the information you gained in the process which, while it doesn't lead to additional compromise, does give you insight into another attack via a different method. So you backtrack and try something else. As such, you shouldn't feel committed or restricted to any one attack vector.