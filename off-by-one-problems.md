## Off-by-One Problems

Suppose you're fuzzing a web endpoint with a wordlist that's been good to you in the past, but what you're looking for lies in a slightly bigger or slightly modified wordlist, so you don't find what you're looking for. Or suppose you're trying to connect to an active directory related service, and it just won't work, until you realize that it appears that the difference between authenticating and being rejected is whether you include the domain IP instead of the hostname. Or suppose you've discovered an RCE vulnerability, which you're trying to leverage to get a shell, but no reverse shell payload seems to work, until you change the port to connect to from 443 to 80.

These are all part and parcel to the off-by-one (ObO) problem/error. They can feel like trench warfare. You're unable to move forward. While trying different variations on the attack, since you haven't recognized the particular source of why the attack isn't working (because although you have the right idea, the error is just so small), you seem to dig yourself further in. The amount of effort you're throwing at the problem does not result in a comensurate improvement of circumstances.

ObO is made all the more harder for the attacker to fix because he may not be able to see any output, particularly error output. Even if there is no error with the command itself, there may be some configuration elsewhere that you're unaware of that prevents the desired execution.

Strategies for dealing with ObO include:

1. Assume the problem to be ObO until proven otherwise: you may be on the right track, but an ObO might make you move on too soon. Instead, assume your approach is correct, but need to modify just one or two aspects of your tests. The problem may not be ObO, but the interest to protect here is that certain findings might be real breakthroughs in your engagement and you need to conduct enough tests before moving on.

2. Conduct slight variations of the same test, observing tbe results each time. This is a good idea to do even when the test apparently is working because failure can tell you more about the underlying configuration. In other words, once you get it "right," getting it wrong will help you feel for the edges to determine how off you can be from this point and still get a meaningful result. In the case of web fuzzing, you can quickly set these tests up and let them work in the background as you do more manual tests.

3. Simplify your tests until the result you see matches your expectations, then gradually add upon this foundation, provided your expectations are justified. The degree to which your expectations are justified will dictate how long you should spend wrestling with the problem. Having a good idea of what the expected result looks like will guide you through the changes you need to make. In practice, if there is a PoC available, try this first. Mind you, just because the PoC doesn't work the first time out of the box doesn't mean it won't work at all. The point is that the PoC provides you with an expected result to look for, and usually, if a PoC is written well, it will provide you already with a simple demonstration. If you're using a new tool, test it under circumstances that prove that it works, like your own attacking machine. Until you know it works and how it should work, if you're applying this to a target, you're blind in three ways: 1) you don't know if the tool is functional, 2) you don't know what the output should look like, and 3) you have no way of knowing what to tweak as you apply the tool to the target.

4. If slight variations in an approach aren't helping, try a major change for comparison. The situation I encounter requiring this sort of change in tactics is after I've gotten some level of code execution and want to get a shell, but no reverse shell command seems to work for some reason. I can go through different reverse shell commands listed [here](https://www.revshells.com/), but nothing seems to take, including encoding the command in base64 to eliminate special characters, and piping the decoded command to be executed in a shell. In such instances, I've had luck uploading a reverse shell binary and then executing it, or adding my public key to a user's `authorized_keys` and then ssh'ing into the account, or hosting a key binary through an SMB share and having the target connect to it, or cURLing a reverse shell script that I host on my machine and then piping the result to a shell...this list can go on. And it has to because so often you will be blocked and the only way to continue is to dislocate whatever is making the target fortified against attack by doing something completely different.